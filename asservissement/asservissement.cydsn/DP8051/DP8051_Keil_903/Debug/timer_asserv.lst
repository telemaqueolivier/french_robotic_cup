C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE TIMER_ASSERV
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_903\Debug\timer_asserv.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\2.0\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\timer_asserv.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_903\Debug\timer_asserv.lst) CD DB
                    - NOIP OT(2,SIZE) INCDIR(Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_903\Debug\timer_asserv.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: timer_asserv.c  
   3          * Version 2.0
   4          *
   5          * Description:
   6          *  The Timer User Module consists of a 8, 16, 24 or 32-bit timer with
   7          *  a selectable period between 2 and 2^Width - 1.  The timer may free run
   8          *  or be used as a capture timer as well.  The capture can be initiated
   9          *  by a positive or negative edge signal as well as via software.
  10          *  A trigger input can be programmed to enable the timer on rising edge
  11          *  falling edge, either edge or continous run.
  12          *  Interrupts may be generated due to a terminal count condition
  13          *  or a capture event.
  14          *
  15          * Note:
  16          *
  17          ********************************************************************************
  18          * Copyright 2008-2010, Cypress Semiconductor Corporation.  All rights reserved.
  19          * You may use this file only in accordance with the license, terms, conditions, 
  20          * disclaimers, and limitations in the end user license agreement accompanying 
  21          * the software package with which this file was provided.
  22          ********************************************************************************/
  23          
  24          #include "timer_asserv.h"
  25          
  26          uint8 timer_asserv_initVar = 0u;
  27          
  28          
  29          /*******************************************************************************
  30          * Function Name: timer_asserv_Init
  31          ********************************************************************************
  32          * 
  33          * Summary:
  34          *  Initialize to the schematic state
  35          * 
  36          * Parameters:  
  37          *  void  
  38          *
  39          * Return: 
  40          *  void
  41          *
  42          *******************************************************************************/
  43          void timer_asserv_Init(void) 
  44          {
  45   1          #if(!timer_asserv_UsingFixedFunction) 
  46   1                  /* Interrupt State Backup for Critical Region*/
  47   1                  uint8 timer_asserv_interruptState;
  48   1          #endif
  49   1      
  50   1          #if (timer_asserv_UsingFixedFunction)
                      /* Clear all bits but the enable bit (if it's already set) for Timer operation */
                      timer_asserv_CONTROL &= timer_asserv_CTRL_ENABLE;
                      
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 2   

                      /* Clear the mode bits for continuous run mode */
                      #if (timer_asserv_PSOC3_ES2 || timer_asserv_PSOC5_ES1)
                          timer_asserv_CONTROL2 &= ~timer_asserv_CTRL_MODE_MASK;
                      #endif
                      #if (timer_asserv_PSOC3_ES3 || timer_asserv_PSOC5_ES2)
                          timer_asserv_CONTROL3 &= ~timer_asserv_CTRL_MODE_MASK;                
                      #endif
              
                      /* Check if One Shot mode is enabled i.e. RunMode !=0*/
                      #if (timer_asserv_RunModeUsed != 0x0u)
                          /* Set 3rd bit of Control register to enable one shot mode */
                          timer_asserv_CONTROL |= 0x04u;
                      #endif
                      
                      #if (timer_asserv_RunModeUsed == 2)
                          #if (timer_asserv_PSOC3_ES2 || timer_asserv_PSOC5_ES1)
                              /* Set last 2 bits of control2 register if one shot(halt on 
                              interrupt) is enabled*/
                              timer_asserv_CONTROL2 |= 0x03u;
                          #endif
                          #if (timer_asserv_PSOC3_ES3 || timer_asserv_PSOC5_ES2)
                              /* Set last 2 bits of control3 register if one shot(halt on 
                              interrupt) is enabled*/
                              timer_asserv_CONTROL3 |= 0x03u;                
                          #endif
                      #endif
                      
                      #if (timer_asserv_UsingHWEnable != 0)
                          #if (timer_asserv_PSOC3_ES2 || timer_asserv_PSOC5_ES1)
                              /* Set the default Run Mode of the Timer to Continuous */
                              timer_asserv_CONTROL2 |= timer_asserv_CTRL_MODE_PULSEWIDTH;
                          #endif
                          #if (timer_asserv_PSOC3_ES3 || timer_asserv_PSOC5_ES2)
                              /* Clear and Set ROD and COD bits of CFG2 register */
                              timer_asserv_CONTROL3 &= ~timer_asserv_CTRL_RCOD_MASK;
                              timer_asserv_CONTROL3 |= timer_asserv_CTRL_RCOD;  
                              
                              /* Clear and Enable the HW enable bit in CFG2 register */
                              timer_asserv_CONTROL3 &= ~timer_asserv_CTRL_ENBL_MASK;
                              timer_asserv_CONTROL3 |= timer_asserv_CTRL_ENBL;     
                              
                              /* Set the default Run Mode of the Timer to Continuous */
                              timer_asserv_CONTROL3 |= timer_asserv_CTRL_MODE_CONTINUOUS;
                          #endif
                      #endif
                      
                      /* Clear and Set SYNCTC and SYNCCMP bits of RT1 register */
                      timer_asserv_RT1 &= ~timer_asserv_RT1_MASK;
                      timer_asserv_RT1 |= timer_asserv_SYNC;     
                              
                      /*Enable DSI Sync all all inputs of the Timer*/
                      timer_asserv_RT1 &= ~(timer_asserv_SYNCDSI_MASK);
                      timer_asserv_RT1 |= timer_asserv_SYNCDSI_EN;
                              
                      /* Set the IRQ to use the status register interrupts */
                      timer_asserv_CONTROL2 |= timer_asserv_CTRL2_IRQ_SEL;
                  #endif 
 111   1              
 112   1          /* Set Initial values from Configuration */
 113   1          timer_asserv_WritePeriod(timer_asserv_INIT_PERIOD);
 114   1          timer_asserv_WriteCounter(timer_asserv_INIT_PERIOD);
 115   1          
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 3   

 116   1          #if (timer_asserv_UsingHWCaptureCounter)/* Capture counter is enabled */
                      timer_asserv_CAPTURE_COUNT_CTRL |= timer_asserv_CNTR_ENABLE;
                      timer_asserv_SetCaptureCount(timer_asserv_INIT_CAPTURE_COUNT);
                  #endif
 120   1              
 121   1          #if (!timer_asserv_UsingFixedFunction)
 122   1              #if (timer_asserv_SoftwareCaptureMode)
                          timer_asserv_SetCaptureMode(timer_asserv_INIT_CAPTURE_MODE);
                      #endif
 125   1              
 126   1              #if (timer_asserv_SoftwareTriggerMode)
                          if (!(timer_asserv_CONTROL & timer_asserv__B_TIMER__TM_SOFTWARE))
                          {
                              timer_asserv_SetTriggerMode(timer_asserv_INIT_TRIGGER_MODE);
                          }
                      #endif
 132   1              
 133   1              /* CyEnterCriticalRegion and CyExitCriticalRegion are used to mark following region critical*/
 134   1              /* Enter Critical Region*/
 135   1              timer_asserv_interruptState = CyEnterCriticalSection();
 136   1              
 137   1              /* Use the interrupt output of the status register for IRQ output */
 138   1              timer_asserv_STATUS_AUX_CTRL |= timer_asserv_STATUS_ACTL_INT_EN_MASK;
 139   1              
 140   1              /* Exit Critical Region*/
 141   1              CyExitCriticalSection(timer_asserv_interruptState);
 142   1      
 143   1              #if (timer_asserv_EnableTriggerMode)
                          timer_asserv_EnableTrigger();
                      #endif
 146   1      
 147   1              #if (timer_asserv_InterruptOnCaptureCount)
                           #if (!timer_asserv_ControlRegRemoved)
                              timer_asserv_SetInterruptCount(timer_asserv_INIT_INT_CAPTURE_COUNT);
                          #endif
                      #endif
 152   1              
 153   1              timer_asserv_ClearFIFO();  
 154   1          #endif
 155   1      
 156   1          timer_asserv_SetInterruptMode(timer_asserv_INIT_INTERRUPT_MODE);
 157   1      }
 158          
 159          
 160          /*******************************************************************************
 161          * Function Name: timer_asserv_Enable
 162          ********************************************************************************
 163          * 
 164          * Summary:
 165          *  Enable the Timer
 166          * 
 167          * Parameters:  
 168          *  void  
 169          *
 170          * Return: 
 171          *  void
 172          *
 173          *******************************************************************************/
 174          void timer_asserv_Enable(void) 
 175          {
 176   1          /* Globally Enable the Fixed Function Block chosen */
 177   1          #if (timer_asserv_UsingFixedFunction)
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 4   

                      timer_asserv_GLOBAL_ENABLE |= timer_asserv_BLOCK_EN_MASK;
                      timer_asserv_GLOBAL_STBY_ENABLE |= timer_asserv_BLOCK_STBY_EN_MASK;
                  #endif   
 181   1          
 182   1          /* Remove assignment if control register is removed */
 183   1          #if (!timer_asserv_ControlRegRemoved || timer_asserv_UsingFixedFunction)     
 184   1              timer_asserv_CONTROL |= timer_asserv_CTRL_ENABLE;
 185   1          #endif
 186   1      }
 187          
 188          
 189          /*******************************************************************************
 190          * Function Name: timer_asserv_Start
 191          ********************************************************************************
 192          * 
 193          * Summary:
 194          *  The start function initializes the timer with the default values, the 
 195          *  enables the timerto begin counting.  It does not enable interrupts,
 196          *  the EnableInt command should be called if interrupt generation is required.
 197          *
 198          * Parameters:  
 199          *  void  
 200          *
 201          * Return: 
 202          *  void
 203          *
 204          * Global variables:
 205          *  timer_asserv_initVar: Is modified when this function is called for the first 
 206          *   time. Is used to ensure that initialization happens only once.
 207          *
 208          * Reentrant
 209          *  No
 210          *
 211          *******************************************************************************/
 212          void timer_asserv_Start(void) 
 213          {
 214   1          if(timer_asserv_initVar == 0u)
 215   1          {
 216   2              timer_asserv_Init();
 217   2              
 218   2              timer_asserv_initVar = 1u;   /* Clear this bit for Initialization */
 219   2          }
 220   1          
 221   1          /* Enable the Timer */              
 222   1          timer_asserv_Enable();    
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: timer_asserv_Stop
 228          ********************************************************************************
 229          * 
 230          * Summary:
 231          *  The stop function halts the timer, but does not change any modes or disable
 232          *  interrupts.
 233          *
 234          * Parameters:  
 235          *  void  
 236          *
 237          * Return: 
 238          *  void
 239          *
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 5   

 240          * Side Effects: If the Enable mode is set to Hardware only then this function
 241          *               has no effect on the operation of the timer.
 242          * Reentrant
 243          *  Yes
 244          *
 245          *******************************************************************************/
 246          void timer_asserv_Stop(void) 
 247          {
 248   1          /* Disable Timer */
 249   1          #if(!timer_asserv_ControlRegRemoved || timer_asserv_UsingFixedFunction)    /* Remove assignment if con
             -trol register is removed */  
 250   1              timer_asserv_CONTROL &= ~timer_asserv_CTRL_ENABLE;
 251   1          #endif  
 252   1          
 253   1          /* Globally disable the Fixed Function Block chosen */
 254   1          #if (timer_asserv_UsingFixedFunction)
                      timer_asserv_GLOBAL_ENABLE &= ~timer_asserv_BLOCK_EN_MASK;
                      timer_asserv_GLOBAL_STBY_ENABLE &= ~timer_asserv_BLOCK_STBY_EN_MASK;
                  #endif
 258   1      }
 259          
 260          
 261          /*******************************************************************************
 262          * Function Name: timer_asserv_SetInterruptMode
 263          ********************************************************************************
 264          * 
 265          * Summary:
 266          *  This function selects which of the interrupt inputs may cause an interrupt.  
 267          *  The twosources are caputure and terminal.  One, both or neither may 
 268          *  be selected.
 269          *
 270          * Parameters:  
 271          *  interruptMode:   This parameter is used to enable interrups on either/or 
 272          *                   terminal count or capture.  
 273          *
 274          * Return: 
 275          *  void
 276          *
 277          * Reentrant
 278          *  Yes
 279          *
 280          *******************************************************************************/
 281          void timer_asserv_SetInterruptMode(uint8 interruptMode) 
 282          {
 283   1          timer_asserv_STATUS_MASK = interruptMode;
 284   1      }
 285          
 286          /*******************************************************************************
 287          * Function Name: timer_asserv_SoftwareCapture
 288          ********************************************************************************
 289          * 
 290          * Summary:
 291          *  This function forces a capture independent of the capture signal.
 292          *
 293          * Parameters:  
 294          *  void
 295          *
 296          * Return: 
 297          *  void
 298          *
 299          * Side Effects:
 300          *  An existing hardware capture could be overwritten.
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 6   

 301          *
 302          * Reentrant
 303          *  Yes
 304          *
 305          *******************************************************************************/
 306          void timer_asserv_SoftwareCapture(void) 
 307          {
 308   1          /* Generate a software capture by reading the counter register */
 309   1          CY_GET_REG8(timer_asserv_COUNTER_LSB_PTR);
 310   1          /* Capture Data is now in the FIFO */
 311   1      }
 312          
 313          
 314          /*******************************************************************************
 315          * Function Name: timer_asserv_ReadStatusRegister
 316          ********************************************************************************
 317          * 
 318          * Summary:
 319          *  Reads the status register and returns it's state. This function should use
 320          *  defined types for the bit-field information as the bits in this register may
 321          *  be permuteable.
 322          *
 323          * Parameters:  
 324          *  void
 325          *
 326          * Return: 
 327          *  The contents of the status register
 328          *
 329          * Side Effects:
 330          *  Status register bits may be clear on read. 
 331          *
 332          * Reentrant
 333          *  Yes
 334          *
 335          *******************************************************************************/
 336          uint8   timer_asserv_ReadStatusRegister(void) 
 337          {
 338   1          return timer_asserv_STATUS;
 339   1      }
 340          
 341          
 342          #if (!timer_asserv_ControlRegRemoved)   /* Remove API if control register is removed */
 343          /*******************************************************************************
 344          * Function Name: timer_asserv_ReadControlRegister
 345          ********************************************************************************
 346          * 
 347          * Summary:
 348          *  Reads the control register and returns it's value. 
 349          *
 350          * Parameters:  
 351          *  void
 352          *
 353          * Return: 
 354          *  The contents of the control register
 355          *
 356          * Reentrant
 357          *  Yes
 358          *
 359          *******************************************************************************/
 360          uint8 timer_asserv_ReadControlRegister(void) 
 361          {
 362   1          return timer_asserv_CONTROL;
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 7   

 363   1      }
 364          
 365          
 366          /*******************************************************************************
 367          * Function Name: timer_asserv_WriteControlRegister
 368          ********************************************************************************
 369          * 
 370          * Summary:
 371          *  Sets the bit-field of the control register.  
 372          *
 373          * Parameters:  
 374          *  control: The contents of the control register
 375          *
 376          * Return: 
 377          *  
 378          * Reentrant
 379          *  Yes
 380          *
 381          *******************************************************************************/
 382          void timer_asserv_WriteControlRegister(uint8 control) 
 383          {
 384   1          timer_asserv_CONTROL = control;
 385   1      }
 386          #endif /* Remove API if control register is removed */
 387          
 388          
 389          /*******************************************************************************
 390          * Function Name: timer_asserv_ReadPeriod
 391          ********************************************************************************
 392          * 
 393          * Summary:
 394          *  This function returns the current value of the Period.
 395          *
 396          * Parameters:  
 397          *  void
 398          *
 399          * Return: 
 400          *  The present value of the counter.
 401          *
 402          * Reentrant
 403          *  Yes
 404          *
 405          *******************************************************************************/
 406          uint32 timer_asserv_ReadPeriod(void) 
 407          {
 408   1         return ( CY_GET_REG24(timer_asserv_PERIOD_LSB_PTR) );  
 409   1      }
 410          
 411          
 412          /*******************************************************************************
 413          * Function Name: timer_asserv_WritePeriod
 414          ********************************************************************************
 415          * 
 416          * Summary:
 417          *  This function is used to change the period of the counter.  The new period 
 418          *  will be loaded the next time terminal count is detected.
 419          *
 420          * Parameters:  
 421          *  period: This value may be between 1 and (2^Resolution)-1.  A value of 0 will result in
 422          *          the counter remaining at zero.
 423          *
 424          * Return: 
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 8   

 425          *  void
 426          *
 427          * Reentrant
 428          *  Yes
 429          *
 430          *******************************************************************************/
 431          void timer_asserv_WritePeriod(uint32 period) 
 432          {
 433   1          #if(timer_asserv_UsingFixedFunction)
                      uint16 period_temp = (uint16)period;
                      CY_SET_REG16(timer_asserv_PERIOD_LSB_PTR, period_temp);
                  #else
 437   1              CY_SET_REG24(timer_asserv_PERIOD_LSB_PTR, period);
 438   1          #endif
 439   1      }
 440          
 441          
 442          /*******************************************************************************
 443          * Function Name: timer_asserv_ReadCapture
 444          ********************************************************************************
 445          * 
 446          * Summary:
 447          *  This function returns the last value captured.
 448          *
 449          * Parameters:  
 450          *  void 
 451          *
 452          * Return: 
 453          *  Present Capture value.
 454          *
 455          * Reentrant
 456          *  Yes
 457          *
 458          *******************************************************************************/
 459          uint32 timer_asserv_ReadCapture(void) 
 460          {
 461   1         return ( CY_GET_REG24(timer_asserv_CAPTURE_LSB_PTR) );  
 462   1      }
 463          
 464          
 465          /*******************************************************************************
 466          * Function Name: timer_asserv_WriteCounter
 467          ********************************************************************************
 468          * 
 469          * Summary:
 470          *  This funtion is used to set the counter to a specific value
 471          *
 472          * Parameters:  
 473          *  counter:  New counter value. 
 474          *
 475          * Return: 
 476          *  void 
 477          *
 478          * Reentrant
 479          *  Yes
 480          *
 481          *******************************************************************************/
 482          void timer_asserv_WriteCounter(uint32 counter) 
 483          {
 484   1          #if(timer_asserv_UsingFixedFunction)
                      counter = counter;
                      /* This functionality is removed until a FixedFunction HW update to 
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 9   

                       * allow this register to be written 
                       */
                      /* uint16 counter_temp = (uint16)counter;
                       * CY_SET_REG16(timer_asserv_COUNTER_LSB_PTR, counter_temp);
                       */
                  #else
 493   1              CY_SET_REG24(timer_asserv_COUNTER_LSB_PTR, counter);
 494   1          #endif
 495   1      }
 496          
 497          
 498          /*******************************************************************************
 499          * Function Name: timer_asserv_ReadCounter
 500          ********************************************************************************
 501          * 
 502          * Summary:
 503          *  This function returns the current counter value.
 504          *
 505          * Parameters:  
 506          *  void
 507          *
 508          * Return: 
 509          *  Present compare value. 
 510          *
 511          * Reentrant
 512          *  Yes
 513          *
 514          *******************************************************************************/
 515          uint32 timer_asserv_ReadCounter(void) 
 516          {
 517   1          
 518   1          /* Force capture by reading Accumulator */
 519   1          /* Must first do a software capture to be able to read the counter */
 520   1          /* It is up to the user code to make sure there isn't already captured data in the FIFO */
 521   1          CY_GET_REG8(timer_asserv_COUNTER_LSB_PTR);
 522   1          
 523   1          /* Read the data from the FIFO (or capture register for Fixed Function)*/
 524   1          return (CY_GET_REG24(timer_asserv_CAPTURE_LSB_PTR));
 525   1      }
 526          
 527          
 528          #if(!timer_asserv_UsingFixedFunction) /* UDB Specific Functions */
 529          
 530          /*******************************************************************************
 531           * The functions below this point are only available using the UDB 
 532           * implementation.  If a feature is selected, then the API is enabled.
 533           ******************************************************************************/
 534          
 535          
 536          #if (timer_asserv_SoftwareCaptureMode)
              /*******************************************************************************
              * Function Name: timer_asserv_SetCaptureMode
              ********************************************************************************
              * 
              * Summary:
              *  This function sets the capture mode to either rising or falling edge.
              *
              * Parameters:  
              *  captureMode:  This parameter sets the capture mode of the UDB capture feature.
              *  The parameter values are defined using the #define timer_asserv__B_TIMER__CM_NONE 0
              #define timer_asserv__B_TIMER__CM_RISINGEDGE 1
              #define timer_asserv__B_TIMER__CM_FALLINGEDGE 2
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 10  

              #define timer_asserv__B_TIMER__CM_EITHEREDGE 3
              #define timer_asserv__B_TIMER__CM_SOFTWARE 4
              . 
              *  The following are the possible values of the parameter
              *  timer_asserv__B_TIMER__CM_NONE        - Set Capture mode to None
              *  timer_asserv__B_TIMER__CM_RISINGEDGE  - Capture on rising edge of Capture input
              *  timer_asserv__B_TIMER__CM_FALLINGEDGE - Capture on falling edge of Capture input
              *  timer_asserv__B_TIMER__CM_EITHEREDGE  - Capture on falling edge of Capture input
              * 
              * Return: 
              *  void
              *
              * Reentrant
              *  Yes
              *
              *******************************************************************************/
              void timer_asserv_SetCaptureMode(uint8 captureMode) 
              {
                  /* This must only set to two bits of the control register associated */
                  captureMode = (captureMode << timer_asserv_CTRL_CAP_MODE_SHIFT);
                  captureMode &= (timer_asserv_CTRL_CAP_MODE_MASK);
                  
                      /* Clear the Current Setting */
                  timer_asserv_CONTROL &= ~timer_asserv_CTRL_CAP_MODE_MASK;
                  
                  /* Write The New Setting */   
                  timer_asserv_CONTROL |= captureMode;
              }
              #endif
 578          
 579          #if (timer_asserv_SoftwareTriggerMode)
              /*******************************************************************************
              * Function Name: timer_asserv_SetTriggerMode
              ********************************************************************************
              * 
              * Summary:
              *  This function sets the trigger input mode
              *
              * Parameters:  
              *  triggerMode: Pass one of the pre-defined Trigger Modes (except Software)
                  #define timer_asserv__B_TIMER__TM_NONE 0x00
                  #define timer_asserv__B_TIMER__TM_RISINGEDGE 0x04
                  #define timer_asserv__B_TIMER__TM_FALLINGEDGE 0x08
                  #define timer_asserv__B_TIMER__TM_EITHEREDGE 0x0C
                  #define timer_asserv__B_TIMER__TM_SOFTWARE 0x10
              *
              * Return: 
              *  void
              *
              * Reentrant
              *  Yes
              *
              *******************************************************************************/
              void timer_asserv_SetTriggerMode(uint8 triggerMode) 
              {
                  /* This must only set to two bits of the control register associated */
                  triggerMode &= timer_asserv_CTRL_TRIG_MODE_MASK;
                  
                  /* Clear the Current Setting */
                  timer_asserv_CONTROL &= ~timer_asserv_CTRL_TRIG_MODE_MASK;
                  
                  /* Write The New Setting */   
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 11  

                  timer_asserv_CONTROL |= (triggerMode | timer_asserv__B_TIMER__TM_SOFTWARE);     
              
              }
              #endif
 615          
 616          #if (timer_asserv_EnableTriggerMode)
              /*******************************************************************************
              * Function Name: timer_asserv_EnableTrigger
              ********************************************************************************
              * 
              * Summary:
              *  Sets the control bit enabling Hardware Trigger mode
              *
              * Parameters:  
              *  void
              *
              * Return: 
              *  void
              *
              * Reentrant
              *  Yes
              *
              *******************************************************************************/
              void timer_asserv_EnableTrigger(void) 
              {
                  #if (!timer_asserv_ControlRegRemoved)   /* Remove assignment if control register is removed */
                      timer_asserv_CONTROL |= timer_asserv_CTRL_TRIG_EN;
                  #endif
              }
              
              /*******************************************************************************
              * Function Name: timer_asserv_DisableTrigger
              ********************************************************************************
              * 
              * Summary:
              *  Clears the control bit enabling Hardware Trigger mode
              *
              * Parameters:  
              *  void
              *
              * Return: 
              *  void
              *
              * Reentrant
              *  Yes
              *
              *******************************************************************************/
              void timer_asserv_DisableTrigger(void) 
              {
                  #if (!timer_asserv_ControlRegRemoved)   /* Remove assignment if control register is removed */
                      timer_asserv_CONTROL &= ~timer_asserv_CTRL_TRIG_EN;
                  #endif
              }
              #endif
 665          
 666          
 667          #if(timer_asserv_InterruptOnCaptureCount)
              #if (!timer_asserv_ControlRegRemoved)   /* Remove API if control register is removed */
              /*******************************************************************************
              * Function Name: timer_asserv_SetInterruptCount
              ********************************************************************************
              * 
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 12  

              * Summary:
              *  This function sets the capture count before an interrupt is triggered.
              *
              * Parameters:  
              *  interruptCount:  A value between 0 and 3 is valid.  If the value is 0, then 
              *                   an interrupt will occur each time a capture occurs.  
              *                   A value of 1 to 3 will cause the interrupt  
              *                   to delay by the same number of captures.
              *
              * Return: 
              *  void
              *
              * Reentrant
              *  Yes
              *
              *******************************************************************************/
              void timer_asserv_SetInterruptCount(uint8 interruptCount) 
              {
                  /* This must only set to two bits of the control register associated */
                  interruptCount &= timer_asserv_CTRL_INTCNT_MASK;
                  
                  /* Clear the Current Setting */
                  timer_asserv_CONTROL &= ~timer_asserv_CTRL_INTCNT_MASK;
                  /* Write The New Setting */   
                  timer_asserv_CONTROL |= interruptCount;    
              }
              #endif /* Remove API if control register is removed */
              #endif /* timer_asserv_InterruptOnCaptureCount */
 701          
 702          
 703          #if (timer_asserv_UsingHWCaptureCounter)
              /*******************************************************************************
              * Function Name: timer_asserv_SetCaptureCount
              ********************************************************************************
              * 
              * Summary:
              *  This function sets the capture count
              *
              * Parameters:  
              *  captureCount: A value between 2 and 127 inclusive is valid.  A value of 1 
              *                to 127 will cause the interrupt to delay by the same number of 
              *                captures.
              *
              * Return: 
              *  void
              *
              * Reentrant
              *  Yes
              *
              *******************************************************************************/
              void timer_asserv_SetCaptureCount(uint8 captureCount) 
              {
                  timer_asserv_CAP_COUNT = captureCount;
              }
              
              
              /*******************************************************************************
              * Function Name: timer_asserv_ReadCaptureCount
              ********************************************************************************
              * 
              * Summary:
              *  This function reads the capture count setting
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 13  

              *
              * Parameters:  
              *  void
              *
              * Return: 
              *  Returns the Capture Count Setting
              *
              *******************************************************************************/
              uint8 timer_asserv_ReadCaptureCount(void) 
              {
                  return timer_asserv_CAP_COUNT ;
              }
              #endif /* timer_asserv_UsingHWCaptureCounter */
 748          
 749          
 750          /*******************************************************************************
 751          * Function Name: timer_asserv_ClearFIFO
 752          ********************************************************************************
 753          * 
 754          * Summary:
 755          *  This function clears all capture data from the capture FIFO
 756          *
 757          * Parameters:  
 758          *  void
 759          *
 760          * Return: 
 761          *  void
 762          *
 763          * Reentrant
 764          *  Yes
 765          *
 766          *******************************************************************************/
 767          void timer_asserv_ClearFIFO(void) 
 768          {
 769   1          while(timer_asserv_ReadStatusRegister() & timer_asserv_STATUS_FIFONEMP)
 770   1          {
 771   2              timer_asserv_ReadCapture();
 772   2          }
 773   1      }
 774          
 775          #endif /* UDB Specific Functions */
 776          
 777          
 778          /* [] END OF FILE */
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 14  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION timer_asserv_Init (BEGIN)
                                           ; SOURCE LINE # 43
                                           ; SOURCE LINE # 44
                                           ; SOURCE LINE # 113
0000 7FBF              MOV     R7,#0BFH
0002 7ED4              MOV     R6,#0D4H
0004 7D01              MOV     R5,#01H
0006 7C00              MOV     R4,#00H
0008 120000      R     LCALL   _timer_asserv_WritePeriod
                                           ; SOURCE LINE # 114
000B 7FBF              MOV     R7,#0BFH
000D 7ED4              MOV     R6,#0D4H
000F 7D01              MOV     R5,#01H
0011 7C00              MOV     R4,#00H
0013 120000      R     LCALL   _timer_asserv_WriteCounter
                                           ; SOURCE LINE # 135
0016 120000      E     LCALL   CyEnterCriticalSection
0019 900000      R     MOV     DPTR,#timer_asserv_interruptState
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
001E 906492            MOV     DPTR,#06492H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 4410              ORL     A,#010H
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 141
0029 900000      R     MOV     DPTR,#timer_asserv_interruptState
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 153
0031 120000      R     LCALL   timer_asserv_ClearFIFO
                                           ; SOURCE LINE # 156
0034 7F01              MOV     R7,#01H
0036 120000      R     LCALL   _timer_asserv_SetInterruptMode
                                           ; SOURCE LINE # 157
0039 22                RET     
             ; FUNCTION timer_asserv_Init (END)

             ; FUNCTION timer_asserv_Enable (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 184
0000 906574            MOV     DPTR,#06574H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 4480              ORL     A,#080H
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
000B 22                RET     
             ; FUNCTION timer_asserv_Enable (END)

C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 15  

             ; FUNCTION timer_asserv_Start (BEGIN)
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 213
                                           ; SOURCE LINE # 214
0000 900000      R     MOV     DPTR,#timer_asserv_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0003
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 216
0008 120000      R     LCALL   timer_asserv_Init
                                           ; SOURCE LINE # 218
000B 900000      R     MOV     DPTR,#timer_asserv_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
0011         ?C0003:
                                           ; SOURCE LINE # 222
0011 120000      R     LCALL   timer_asserv_Enable
                                           ; SOURCE LINE # 223
0014 22                RET     
             ; FUNCTION timer_asserv_Start (END)

             ; FUNCTION timer_asserv_Stop (BEGIN)
                                           ; SOURCE LINE # 246
                                           ; SOURCE LINE # 247
                                           ; SOURCE LINE # 250
0000 906574            MOV     DPTR,#06574H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
000B 22                RET     
             ; FUNCTION timer_asserv_Stop (END)

             ; FUNCTION _timer_asserv_SetInterruptMode (BEGIN)
                                           ; SOURCE LINE # 281
0000 900000      R     MOV     DPTR,#interruptMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 283
0005 900000      R     MOV     DPTR,#interruptMode
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906482            MOV     DPTR,#06482H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 284
000F 22                RET     
             ; FUNCTION _timer_asserv_SetInterruptMode (END)

             ; FUNCTION timer_asserv_SoftwareCapture (BEGIN)
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 307
                                           ; SOURCE LINE # 309
0000 906400            MOV     DPTR,#06400H
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 16  

0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 311
0005 22                RET     
             ; FUNCTION timer_asserv_SoftwareCapture (END)

             ; FUNCTION timer_asserv_ReadStatusRegister (BEGIN)
                                           ; SOURCE LINE # 336
                                           ; SOURCE LINE # 337
                                           ; SOURCE LINE # 338
0000 906462            MOV     DPTR,#06462H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 339
0005         ?C0008:
0005 22                RET     
             ; FUNCTION timer_asserv_ReadStatusRegister (END)

             ; FUNCTION timer_asserv_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 361
                                           ; SOURCE LINE # 362
0000 906574            MOV     DPTR,#06574H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 363
0005         ?C0009:
0005 22                RET     
             ; FUNCTION timer_asserv_ReadControlRegister (END)

             ; FUNCTION _timer_asserv_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 382
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 383
                                           ; SOURCE LINE # 384
0005 900000      R     MOV     DPTR,#control
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906574            MOV     DPTR,#06574H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 385
000F 22                RET     
             ; FUNCTION _timer_asserv_WriteControlRegister (END)

             ; FUNCTION timer_asserv_ReadPeriod (BEGIN)
                                           ; SOURCE LINE # 406
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 408
0000 7B02              MOV     R3,#02H
0002 7A64              MOV     R2,#064H
0004 7920              MOV     R1,#020H
0006 120000      E     LCALL   _cyread24_nodpx
                                           ; SOURCE LINE # 409
0009         ?C0011:
0009 22                RET     
             ; FUNCTION timer_asserv_ReadPeriod (END)

             ; FUNCTION _timer_asserv_WritePeriod (BEGIN)
                                           ; SOURCE LINE # 431
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 17  

0000 900000      R     MOV     DPTR,#period
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 432
                                           ; SOURCE LINE # 437
0006 7B02              MOV     R3,#02H
0008 7A64              MOV     R2,#064H
000A 7920              MOV     R1,#020H
000C 900000      R     MOV     DPTR,#period
000F 120000      E     LCALL   ?C?LLDXDATA
0012 120000      E     LCALL   _cywrite24_nodpx
                                           ; SOURCE LINE # 439
0015 22                RET     
             ; FUNCTION _timer_asserv_WritePeriod (END)

             ; FUNCTION timer_asserv_ReadCapture (BEGIN)
                                           ; SOURCE LINE # 459
                                           ; SOURCE LINE # 460
                                           ; SOURCE LINE # 461
0000 7B02              MOV     R3,#02H
0002 7A64              MOV     R2,#064H
0004 7940              MOV     R1,#040H
0006 120000      E     LCALL   _cyread24_nodpx
                                           ; SOURCE LINE # 462
0009         ?C0013:
0009 22                RET     
             ; FUNCTION timer_asserv_ReadCapture (END)

             ; FUNCTION _timer_asserv_WriteCounter (BEGIN)
                                           ; SOURCE LINE # 482
0000 900000      R     MOV     DPTR,#counter
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 483
                                           ; SOURCE LINE # 493
0006 7B02              MOV     R3,#02H
0008 7A64              MOV     R2,#064H
000A 7900              MOV     R1,#00H
000C 900000      R     MOV     DPTR,#counter
000F 120000      E     LCALL   ?C?LLDXDATA
0012 120000      E     LCALL   _cywrite24_nodpx
                                           ; SOURCE LINE # 495
0015 22                RET     
             ; FUNCTION _timer_asserv_WriteCounter (END)

             ; FUNCTION timer_asserv_ReadCounter (BEGIN)
                                           ; SOURCE LINE # 515
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 521
0000 906400            MOV     DPTR,#06400H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 524
0005 7B02              MOV     R3,#02H
0007 7A64              MOV     R2,#064H
0009 7940              MOV     R1,#040H
000B 120000      E     LCALL   _cyread24_nodpx
                                           ; SOURCE LINE # 525
000E         ?C0015:
000E 22                RET     
             ; FUNCTION timer_asserv_ReadCounter (END)

             ; FUNCTION timer_asserv_ClearFIFO (BEGIN)
                                           ; SOURCE LINE # 767
C51 COMPILER V9.03   TIMER_ASSERV                                                          05/13/2012 22:25:54 PAGE 18  

                                           ; SOURCE LINE # 768
0000         ?C0016:
                                           ; SOURCE LINE # 769
0000 120000      R     LCALL   timer_asserv_ReadStatusRegister
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 30E305            JNB     ACC.3,?C0018
                                           ; SOURCE LINE # 770
                                           ; SOURCE LINE # 771
0009 120000      R     LCALL   timer_asserv_ReadCapture
                                           ; SOURCE LINE # 772
000C 80F2              SJMP    ?C0016
                                           ; SOURCE LINE # 773
000E         ?C0018:
000E 22                RET     
             ; FUNCTION timer_asserv_ClearFIFO (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    247    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
